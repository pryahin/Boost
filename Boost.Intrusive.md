# Глава 18. Boost.Intrusive

Boost.Intrusive это библиотека особенно подходящая для использования в высокоэффективных программах. Библиотека предоставляет инструменты для создания *интрузивных контейнеров*. Эти контейнеры заменяют известные контейнеры из стандартной библиотеки. Их недостаток заключается в том, что они не могут быть использованы так же легко, как, например, `std::list` или `std::set`. Но у них есть следующие преимущества:
- Интрузивные контейнеры не выделяют память динамически. Вызов `push_back()` не приводит к динамическому распределению с `new`. Это одна из причин того, почему интрузивные контейнеры могут улучшить производительность.
- Интрузивные контейнеры хранят исходные объекты, а не копии. В конце концов, они не выделяют память динамически. Это приводит к еще одному преимуществу: Функции, такие как `push_back()` не выдают исключения, потому что они ни выделяют память, ни копируют объекты.

Преимущества оплачиваются более сложным кодом, так как для хранения объектов в интрузивных контейнерах должны быть выполнены предварительные условия. Вы не можете хранить объекты произвольных типов в интрузивных контейнерах. Например, вы не можете поместить строки типа `std::string` в интрузивный контейнер; вместо этого вы должны использовать контейнеры из стандартной библиотеки.

[Пример 18.1](#example181) готовит класс animal, чтобы позволить объектам данного типа быть сохраненными в интрузивном списке.
<a name="example181"></a>
### Пример 18.1. Использование `boost::intrusive::list`
```c++
#include <boost/intrusive/list.hpp>
#include <string>
#include <utility>
#include <iostream>

using namespace boost::intrusive;

struct animal : public list_base_hook<>
{
  std::string name;
  int legs;
  animal(std::string n, int l) : name{std::move(n)}, legs{l} {}
};

int main()
{
  animal a1{"cat", 4};
  animal a2{"shark", 0};
  animal a3{"spider", 8};

  typedef list<animal> animal_list;
  animal_list animals;

  animals.push_back(a1);
  animals.push_back(a2);
  animals.push_back(a3);

  a1.name = "dog";

  for (const animal &a : animals)
    std::cout << a.name << '\n';
}
```
В списке к элементу всегда получить доступ от другого элемента используя указатель. Если интрузивный список должен хранить объекты типа `animal` без динамического распределения памяти указатели должны существовать где-нибудь, чтобы связать элементы.

Для того, чтобы хранить объекты типа `animal` в интрузивном списке, то класс должен предоставить необходимые переменные, требуемые интрузивным списком чтобы связать элементов. Boost.Intrusive обеспечивает *Крюки* - классы, от которых унаследованы необходимые переменные. Чтобы разрешить объектам типа `animal` быть сохраненными в интрузивном списке, `animal` должен быть производным от класса `boost::intrusive::list_base_hook`.

Крюки позволяют игнорировать детали реализации. Тем не менее, можно с уверенностью предположить, что `boost::intrusive::list_base_hook` обеспечивает, по крайней мере два указателя так как `boost::intrusive::list` является двусвязным списком. Благодаря базовому классу `boost::intrusive::list_base_hook`, `animal` определяет эти два указателя, чтобы позволить объектам этого типа быть связанными.

Обратите внимание, что `boost::intrusive::list_base_hook` это шаблон, который поставляется с параметрами шаблона по умолчанию. Таким образом, ни один тип не следует передавать в явном виде.

Boost.Intrusive обеспечивает класс `boost::intrusive::list`, чтобы создать интрузивный список. Этот класс определяется в `boost/intrusive/list.hpp` и используется как `std::list`. Элементы могут быть добавлены с помощью `push_back()`, и также можно перебирать элементы.

Важно понимать, что интрузивные контейнеры не хранят копии; они хранят исходные объекты. [Пример 18.1](#example181) пишет **dog**, **shark** и **spider** на стандартный вывод - не **cat**. Объект **a1** связан в списке. Вот почему изменение названия видно, когда программа перебирает элементы в списке, и отображает имена.

Поскольку интрузивные контейнеры не хранят копии, вы должны удалить объекты из интрузивных контейнеров, прежде чем уничтожить их.

<a name="example182"></a>
### Пример 18.2. Удаление и уничтожение динамически выделенных объектов
```c++
#include <boost/intrusive/list.hpp>
#include <string>
#include <utility>
#include <iostream>

using namespace boost::intrusive;

struct animal : public list_base_hook<>
{
  std::string name;
  int legs;
  animal(std::string n, int l) : name{std::move(n)}, legs{l} {}
};

int main()
{
  animal a1{"cat", 4};
  animal a2{"shark", 0};
  animal *a3 = new animal{"spider", 8};

  typedef list<animal> animal_list;
  animal_list animals;

  animals.push_back(a1);
  animals.push_back(a2);
  animals.push_back(*a3);

  animals.pop_back();
  delete a3;

  for (const animal &a : animals)
    std::cout << a.name << '\n';
}
```

[Пример 18.2](#example182) создает объект типа `animal` с `new`, и вставляет его в список **animals**. Если вы хотите уничтожить объект с `delete`, когда он вам больше не нужен, вы должны удалить его из списка. Убедитесь, что вы удалили объект из списка, прежде чем уничтожить его - порядок важен. В противном случае, указатели в элементах интрузивного контейнера могут ссылаться на ячейку памяти, которая больше не содержит объект типа `animal`.

Поскольку интрузивные контейнеры ни выделяют, ни освобождают память, объекты, хранящиеся в интрузивном контейнере продолжают существовать, когда интрузивный контейнер уничтожен.

Так как удаление элементов из интрузивных контейнеров автоматически не уничтожает их, контейнеры обеспечивают нестандартные расширения. `pop_back_and_dispose()` является одной из таких функций.

<a name="example183"></a>
### Пример 18.3. Удаление и уничтожение с `pop_back_and_dispose()`
```c++
#include <boost/intrusive/list.hpp>
#include <string>
#include <utility>
#include <iostream>

using namespace boost::intrusive;

struct animal : public list_base_hook<>
{
  std::string name;
  int legs;
  animal(std::string n, int l) : name{std::move(n)}, legs{l} {}
};

int main()
{
  animal a1{"cat", 4};
  animal a2{"shark", 0};
  animal *a3 = new animal{"spider", 8};

  typedef list<animal> animal_list;
  animal_list animals;

  animals.push_back(a1);
  animals.push_back(a2);
  animals.push_back(*a3);

  animals.pop_back_and_dispose([](animal *a){ delete a; });

  for (const animal &a : animals)
    std::cout << a.name << '\n';
}
```

`pop_back_and_dispose()` удаляет элемент из списка и разрушает его. Поскольку интрузивные контейнеры не знают, как должен быть уничтожен элемент, вам необходимо передать `pop_back_and_dispose()` функцию или функциональный объект, который действительно знает, как уничтожить элемент. `pop_back_and_dispose()` удалит объект из списка, а затем вызовет функцию или функциональный объект, и передаст указатель на объект, который будет уничтожен. [Пример 18.3](#example183) передает лямбда-функцию, которая требует `delete`.

В [Примере 18.3](#example183) только третий элемент **animals** может быть удален с `pop_back_and_dispose()`. Остальные элементы в списке не были созданы с `new` и, таким образом, не должны быть уничтожены с `delete`.

Boost.Intrusive поддерживает другой механизм увязки удаления и уничтожения элементов.

<a name="example184"></a>
### Пример 18.4. Удаление и уничтожение с режимом автоматического разрыва связи (auto unlink mode).
```c++
#include <boost/intrusive/list.hpp>
#include <string>
#include <utility>
#include <iostream>

using namespace boost::intrusive;

typedef link_mode<auto_unlink> mode;

struct animal : public list_base_hook<mode>
{
  std::string name;
  int legs;
  animal(std::string n, int l) : name{std::move(n)}, legs{l} {}
};

int main()
{
  animal a1{"cat", 4};
  animal a2{"shark", 0};
  animal *a3 = new animal{"spider", 8};

  typedef constant_time_size<false> constant_time_size;
  typedef list<animal, constant_time_size> animal_list;
  animal_list animals;

  animals.push_back(a1);
  animals.push_back(a2);
  animals.push_back(*a3);

  delete a3;

  for (const animal &a : animals)
    std::cout << a.name << '\n';
}
```

Крюки поддерживают параметр для установления режима связи. Режим связи устанавливается с помощью шаблона класса `boost::intrusive::link_mode`. Если `boost::intrusive::auto_unlink` передается в качестве параметра шаблона, значит выбран режим автоматического разрыва связи.

Режим автоматического разрыва связи автоматически удаляет элемент из интрузивного контейнера, когда он будет уничтожен. [Пример 18.4](#example184) пишет только **cat** и **shark** в стандартный вывод.

Режим автоматического разрыва связи может использоваться только тогда, когда функция `size()`, которая поддерживается всеми интрузивными контейнерами, не имеет *постоянной сложности*. По умолчанию он имеет постоянную сложность, что означает: время, необходимое для size(), чтобы вернуть количество элементов не зависит от того, сколько элементов хранится в контейнере. Включение постоянной сложности или выключения является еще одним вариантом для оптимизации производительности.

Чтобы изменить сложность `size()`, используйте шаблон класса `boost::intrusive::constant_time_size`, которая ожидает либо `true`, либо `false` в качестве параметра шаблона. `boost::intrusive::constant_time_size` может быть принимать в качестве второго параметра шаблон для интрузивных контейнеров, такой как `boost::intrusive::list`, чтобы установить сложность для `size()`.

Теперь, когда мы видели, что интрузивные контейнеры поддерживают режим связи, и что есть возможность установить сложность для `size()`, может показаться, что для изучения есть гораздо больше режимов, но на самом деле это не так. Есть, например, только три способа связи, и режим автоматического разрыва связи является единственным, который Вам нужно знать. Режим по умолчанию, используемый, если вы не выбрали режим связи, достаточно хорош для всех других случаев.

Кроме того, нет никаких параметров для других функций. Там нет других классов, которые Вам нужно знать, кроме `boost::intrusive::constant_time_size`.

[Пример 18.5](#example185) вводит механизм крюка, используя другой интрузивный контейнер: `boost::intrusive::set`.

<a name="example185"></a>
### Пример 18.5. Определение крюка для `boost::intrusive::set` как переменную экземпляра
```c++
#include <boost/intrusive/set.hpp>
#include <string>
#include <utility>
#include <iostream>

using namespace boost::intrusive;

struct animal
{
  std::string name;
  int legs;
  set_member_hook<> set_hook;
  animal(std::string n, int l) : name{std::move(n)}, legs{l} {}
  bool operator<(const animal &a) const { return legs < a.legs; }
};

int main()
{
  animal a1{"cat", 4};
  animal a2{"shark", 0};
  animal a3{"spider", 8};

  typedef member_hook<animal, set_member_hook<>, &animal::set_hook> hook;
  typedef set<animal, hook> animal_set;
  animal_set animals;

  animals.insert(a1);
  animals.insert(a2);
  animals.insert(a3);

  for (const animal &a : animals)
    std::cout << a.name << '\n';
}
```

Есть два способа добавить крюк к классу: либо вывести класс с крюка или определить крюк в качестве переменной экземпляра. В то время как предыдущие примеры получили класс от `boost::intrusive::list_base_hook`, [Пример 18.5](#example185) использует класс `boost::intrusive::set_member_hook` чтобы определить переменную экземпляра.

Обратите внимание, что имя переменной экземпляра не имеет значения. Тем не менее, класс крюка, который Вы используете, зависит от интрузивного контейнера. Например, чтобы определить крюк в качестве переменной экземпляра для интрузивного списка, используйте `boost::intrusive::list_member_hook` вместо `boost::intrusive::set_member_hook`.

Интрузивные контейнеры имеют различные крюки, поскольку они имеют разные требования к элементам. Тем не менее, вы можете использовать несколько различны крюков, чтобы позволить объекты храниться в нескольких интрузивных контейнерах. `boost::intrusive::any_base_hook` и `boost::intrusive::any_member_hook` позволяют хранить объекты в любом интрузивном контейнере. Благодаря этим классам, вам не нужно выводить из нескольких крюков или определять несколько переменных экземпляра в качестве крюков.

Интрузивные контейнеры ожидают, что крюки будут определены в базовых классах по умолчанию. Если переменная экземпляра используется в качестве крючка, как и в [Примере 18.5](#example185), интрузивный контейнер должен указать, какую переменную экземпляра использовать. Именно поэтому как `animal`, так и `hook` передаются `boost::intrusive::set`. `hook` определяется с `boost::intrusive::member_hook`, который используется всякий раз, когда переменная экземпляра служит в качестве крюка. `boost::intrusive::member_hook` ожидает тип элемента, тип крючка, и указатель на переменную экземпляра в качестве параметров шаблона.

[Пример 18.5](#example185) пишет в стандартный вывод **shark**, **cat** и **spider**, в таком порядке.

В дополнение к классам `boost::intrusive::list` и `boost::intrusive::set`, введенных в этой главе, Boost.Intrusive также предусматривает, например, `boost::intrusive::slist` для односвязных списков и `boost::intrusive::unordered_set` для хэш-контейнеров.
